use crate::{
    db_trait::{Db, Lock},
    CrdbFuture, EventId, ObjectId, TypeId, Updatedness,
};

#[derive(Copy, Clone, Debug, serde::Deserialize, serde::Serialize)]
pub struct UploadId(pub i64);

pub trait ApiConfig: 'static + crate::private::Sealed {
    /// Auto-generated by `crdb::db!`.
    ///
    /// Panics if there are two types with the same ULID configured
    fn check_ulids();

    fn reencode_old_versions<D: Db>(call_on: &D) -> impl '_ + CrdbFuture<Output = usize>;

    /// The returned serde_json::Value is guaranteed to be a serialization of the latest snapshot of the object at the current snapshot version
    #[allow(clippy::too_many_arguments)] // Used only for relaying to a more specific function
    fn recreate<D: Db>(
        db: &D,
        type_id: TypeId,
        object_id: ObjectId,
        created_at: EventId,
        snapshot_version: i32,
        object: &serde_json::Value,
        updatedness: Option<Updatedness>,
        force_lock: Lock,
    ) -> impl CrdbFuture<Output = crate::Result<Option<serde_json::Value>>>;

    /// The returned serde_json::Value is guaranteed to be a serialization of the latest snapshot of the object at the current snapshot version
    fn submit<D: Db>(
        db: &D,
        type_id: TypeId,
        object_id: ObjectId,
        event_id: EventId,
        event: &serde_json::Value,
        updatedness: Option<Updatedness>,
        force_lock: Lock,
    ) -> impl CrdbFuture<Output = crate::Result<Option<serde_json::Value>>>;

    fn remove_event<D: Db>(
        db: &D,
        type_id: TypeId,
        object_id: ObjectId,
        event_id: EventId,
    ) -> impl CrdbFuture<Output = crate::Result<()>>;
}

#[doc(hidden)]
#[macro_export]
macro_rules! generate_api {
    ( $config:ident | $($object:ty),* ) => {
        pub struct $config;

        impl crdb::private::Sealed for $config {}
        impl crdb::ApiConfig for $config {
            fn check_ulids() {
                let ulids = [$(<$object as crdb::Object>::type_ulid()),*];
                for u in ulids.iter() {
                    if ulids.iter().filter(|i| *i == u).count() != 1 {
                        panic!("Type ULID {u:?} was used multiple times!");
                    }
                }
            }

            async fn reencode_old_versions<D: crdb::Db>(call_on: &D) -> usize {
                let mut num_errors = 0;
                $(
                    num_errors += call_on.reencode_old_versions::<$object>().await;
                )*
                num_errors
            }

            async fn recreate<D: crdb::Db>(
                db: &D,
                type_id: crdb::TypeId,
                object_id: crdb::ObjectId,
                created_at: crdb::EventId,
                snapshot_version: i32,
                object: &crdb::serde_json::Value,
                updatedness: Option<crdb::Updatedness>,
                force_lock: crdb::Lock,
            ) -> crdb::Result<Option<crdb::serde_json::Value>> {
                $(
                    if type_id == *<$object as crdb::Object>::type_ulid() {
                        let _ = snapshot_version;
                        let object = <$object as crdb::serde::Deserialize>::deserialize(object)
                            .wrap_with_context(|| format!("failed deserializing object of {type_id:?}"))?;
                        let res = db.recreate::<$object>(object_id, created_at, crdb::Arc::new(object), updatedness, force_lock).await?;
                        let Some(res) = res else {
                            return Ok(None);
                        };
                        let res = crdb::serde_json::to_value(&res).wrap_context("serializing object")?;
                        return Ok(Some(res));
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(type_id))
            }

            async fn submit<D: crdb::Db>(
                db: &D,
                type_id: crdb::TypeId,
                object_id: crdb::ObjectId,
                event_id: crdb::EventId,
                event: &crdb::serde_json::Value,
                updatedness: Option<crdb::Updatedness>,
                force_lock: crdb::Lock,
            ) -> crdb::Result<Option<crdb::serde_json::Value>> {
                $(
                    if type_id == *<$object as crdb::Object>::type_ulid() {
                        let event = <<$object as crdb::Object>::Event as serde::Deserialize>::deserialize(event)
                            .wrap_with_context(|| format!("failed deserializing event of {type_id:?}"))?;
                        let res = db.submit::<$object>(object_id, event_id, crdb::Arc::new(event), updatedness, force_lock).await?;
                        let Some(res) = res else {
                            return Ok(None);
                        };
                        let res = crdb::serde_json::to_value(&res).wrap_context("serializing object")?;
                        return Ok(Some(res));
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(type_id))
            }

            async fn remove_event<D: crdb::Db>(
                db: &D,
                type_id: crdb::TypeId,
                object_id: crdb::ObjectId,
                event_id: crdb::EventId,
            ) -> crdb::Result<()> {
                $(
                    if type_id == *<$object as crdb::Object>::type_ulid() {
                        return db.remove_event::<$object>(object_id, event_id).await;
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(type_id))
            }
        }
    };
}
