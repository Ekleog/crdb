use crate::{
    db_trait::{Db, DynNewEvent, DynNewObject, DynNewRecreation},
    messages::Upload,
    BinPtr, CanDoCallbacks, CrdbFuture,
};

pub(crate) mod query;
pub use query::{JsonPathItem, Query};

#[derive(Copy, Clone, Debug, serde::Deserialize, serde::Serialize)]
pub struct UploadId(pub i64);

#[derive(serde::Deserialize, serde::Serialize)]
pub enum UploadOrBinPtr {
    Upload(Upload),
    BinPtr(BinPtr),
}

pub trait ApiConfig: crate::private::Sealed {
    /// Auto-generated by `crdb::db!`.
    ///
    /// Panics if there are two types with the same ULID configured
    fn check_ulids();

    /// Auto-generated by `crdb::db!`.
    ///
    /// Calls `db`'s `create` method with the proper type and the fields from `o`.
    fn create<D: Db, C: CanDoCallbacks>(
        db: &D,
        o: DynNewObject,
        lock: bool,
        cb: &C,
    ) -> impl CrdbFuture<Output = crate::Result<()>>;

    /// Auto-generated by `crdb::db!`.
    ///
    /// Calls `db`'s `submit` method with the proper type and the fields from `o`.
    fn submit<D: Db, C: CanDoCallbacks>(
        db: &D,
        e: DynNewEvent,
        cb: &C,
    ) -> impl CrdbFuture<Output = crate::Result<()>>;

    /// Auto-generated by `crdb::db!`.
    ///
    /// Calls `db`'s `recreate` method with the proper type and the fields from `s`.
    fn recreate<D: Db, C: CanDoCallbacks>(
        db: &D,
        s: DynNewRecreation,
        cb: &C,
    ) -> impl CrdbFuture<Output = crate::Result<()>>;
}

#[doc(hidden)]
#[macro_export]
macro_rules! generate_api {
    ( $config:ident | $($object:ty),* ) => {
        pub struct $config;

        impl crdb::private::Sealed for $config {}
        impl crdb::ApiConfig for $config {
            fn check_ulids() {
                let ulids = [$(<$object as crdb::Object>::type_ulid()),*];
                for u in ulids.iter() {
                    if ulids.iter().filter(|i| *i == u).count() != 1 {
                        panic!("Type ULID {u:?} was used multiple times!");
                    }
                }
            }

            async fn create<D: crdb::Db, C: crdb::CanDoCallbacks>(db: &D, o: crdb::DynNewObject, lock: bool, cb: &C) -> crdb::Result<()> {
                $(
                    if o.type_id == *<$object as crdb::Object>::type_ulid() {
                        let object = o.object
                            .arc_to_any()
                            .downcast::<$object>()
                            .expect("got new object that could not be downcast to its type_id");
                        return db.create::<$object, _>(o.id, o.created_at, object, lock, cb).await;
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(o.type_id))
            }

            async fn submit<D: crdb::Db, C: crdb::CanDoCallbacks>(db: &D, e: crdb::DynNewEvent, cb: &C) -> crdb::Result<()> {
                $(
                    if e.type_id == *<$object as crdb::Object>::type_ulid() {
                        let event = e.event
                            .arc_to_any()
                            .downcast::<<$object as crdb::Object>::Event>()
                            .expect("got new event that could not be downcast to its type_id");
                        return db.submit::<$object, _>(e.object_id, e.id, event, cb).await;
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(e.type_id))
            }

            async fn recreate<D: crdb::Db, C: crdb::CanDoCallbacks>(db: &D, s: crdb::DynNewRecreation, cb: &C) -> crdb::Result<()> {
                $(
                    if s.type_id == *<$object as crdb::Object>::type_ulid() {
                        return db.recreate::<$object, C>(s.time, s.object_id, cb).await;
                    }
                )*
                Err(crdb::Error::TypeDoesNotExist(s.type_id))
            }
        }
    };
}
